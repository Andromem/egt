namespace egt { inline namespace v1 {
/**

 @page events Events

This chapter discusses the event model and how events are handled.

@section events_loop Event Loop

The EventLoop is the inner loop of the framework. Its basic operation is
demonstrated with the following pseudo code:

@code{.cpp}
while (true)
{
    wait for events
    dispatch events
    draw
}
@endcode

It does this until the event loop is told to exit, and in turn, this usually
means the application exits.  For example, a call to EventLoop::quit() would
cause the event loop to exit.

The event loop in EGT is implemented with the
<a href="https://think-async.com/">Asio</a> library.  Asio is a cross-platform
C++ library for network and low-level I/O programming that provides developers
with a consistent asynchronous model using a modern C++ approach.  Asio can be
used as part of boost or standalone, and EGT comes with the standalone version
built in. Asio provides way more features than what is directly used by EGT.

@imageSize{asio.png,width:400px;}
@image html asio.png "Asio"
@image latex asio.png "Asio" width=8cm

EGT abstracts out any required direct involvement with Asio, however, should you
choose to use it directly it is available for use in, for example, @ref
topics_networking "networking" and @ref topics_threads "multi-threaded"
applications. <a href="http://think-async.com/Asio/asio-1.12.2/doc/index.html">Asio
Documentation</a> is a good reference point if you want to start using the Asio
API directly.

@section events_prop Event Propagation

Every time a user touches the screen, clicks a button, or presses a key, an
event is generated and sent to the event loop and then dispatched to appropriate
handlers. Events can also come from other things like a window manager,
timers, or networking sockets.

Events are usually propagated from the top level widget down.  There are
exceptions to this, for example, when a widget grabs the pointer or keyboard,
then this natural flow is short circuited.  For example, when a TextBox has
keyboard focus.

@image html widget_hierarchy_event.png "Event"
@image latex widget_hierarchy_event.png "Event" width=8cm

@section events_data Event Data

Each event handler, like Widget::handle(), is called with an Event object.  This
object maintains the unique egt::v1::eventid of the event, and any data associated
with the Event such as Pointer or Key event data.

@section events_handling Handling Events

When implementing a Widget that needs to handle events, overriding the the
Widget::handle() virtual method is the expected method to handle events.
However, when using an existing Widget, it can be a burden to subclass just
to handle events.  So, to handle events when using a Widget, the
Widget::on_event() method can be used to register any number of callbacks. A
[lambda](https://en.cppreference.com/w/cpp/language/lambda) function may also be
used.

@code{.cpp}
ImageButton settings("@cog.png");
settings.on_event([this](Event& event)
{
    if (event.id() == eventid::pointer_click)
    {
        if (m_popup.visible())
            m_popup.hide();
        else
            m_popup.show(true);
    }
});
@endcode

Another variation of the Widget::on_event() function allows for specifying
what events to filter as a second parameter.

@code{.cpp}
ImageButton settings("@cog.png");
settings.on_event([this](Event&)
{
    if (m_popup.visible())
        m_popup.hide();
    else
        m_popup.show(true);
}, {eventid::pointer_click});
@endcode

Widget::on_event() can be called any number of times to register any number
of callbacks.

@section events_timers Timers

Timers are an intrinsic part of the EventLoop.  There are two main classes for
working with timers: Timer and PeriodicTimer.

Creating a timer is straightforward, and you can register any number of
callbacks with the Timer::on_timeout() function of a Timer or a
PeriodicTimer.

@code{.cpp}
PeriodicTimer timer(std::chrono::seconds(1));

timer.on_timeout([]()
{
    cout << "timer fired" << endl;
});

timer.start();
@endcode

*/
}}
