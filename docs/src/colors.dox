namespace egt { inline namespace v1 {
/**

 @page colors Theme, Palette, and Colors

This chapter discusses how to to use colors and palettes.

@section colors_palette Palette

The Palette manages a set of colors.  However, colors are not stored as a one
dimensional list internally.  Colors are identified by a Palette::ColorId and
also a Palette::GroupId.  The GroupId is associated with different states of a
Color in the Palette, which corresponds with different states of a Widget.  For
example, when a button is pressed it changes from a normal to active state and
uses the same Palette::ColorId to identify its background color, but uses a
different Palette::GroupId.

The default Palette for every Widget comes from the Theme. However, you can
override any individual Color for a specific Widget instance by calling
Widget::set_color().

@code{.cpp}
Button button(window, "Press Me");
button.set_color(Palette::ColorId::button_text, Palette::green);
@endcode

If you change the global theme, it will retroactively have an effect on any
widget, as long as that widget does not have an override for a Palette::ColorId
and Palette::GroupId set.

The Palette class also defines a set of default colors to reference and use.
With a few minor exceptions, these are the same colors defined by the [CSS
standard](https://www.w3.org/TR/css-color-3/).

@todo Talk about Color and Pattern class.

@section colors_themes Widget Theme

The Theme contains the default Palette and Fonts and also can be used as a place
to override Widget::draw() methods.

By default, themes are inherited with the widget hierarchy.  If the Window does
not have a custom theme or a widget does not have a parent, it will use the
egt::global_theme() by default. So, when you add a Button Widget to a Window,
that button will use the theme from the Window and on up the widget hierarchy as
needed.  This means if you change the Font of the Window theme, the button and
all of its children will inherit that change.  Each Widget can hold its own
instance of a Theme, set with Widget::set_theme().

@see custom for more information on how to create custom widgets.

EGT does not use native style widgets by default.  It defines the look and feel
of its own widgets, which is customizable.  The look and feel of widgets can be
extended or modified in several ways.

1. The first method is to register a new draw() function for a specific widget
   type.  This will make the new draw function apply to any widget of the same
   type.
2. The second method is to derive from an existing widget and create a new
   widget type, with a new default draw function.

@section theme_overview Theme Inheritance

Theme is a class that holds a palette, font, and drawing functions used by
widgets.  By default, there is a global_theme() that is used by all widgets.
This can be changed by calling set_global_theme().

Each Widget references a Theme through its Widget::theme() call.  However,
theme's are inherited by default from a Widget's parent.  If no parent widget
has a theme, the global_theme() is used by default.

To break the inheritance, call Widget::set_theme().  This will cause the Widget
to maintain its own theme and not inherit from its parent or the global theme.
So, if you change the theme for a Window, all of its child widgets will inherit
that theme by default unless you call Widget::set_theme() on one of the
children.

Inheritance of the Theme provides a natural and flexible way to manage the look
of widgets with less code.

@section theme_default_draw Widget Type Default Draw Functions

Each widget type has a default_draw() function that implements the EGT default
drawing method for the widget type. This function provides an example how how
you would implement your own draw function to customize the look of a widget.

@section theme_type_draw Widget Type Draw Functions

It is possible to change the draw() function for a Widget type globally based
only on the widget's c++ type.  For example, you can change the draw() function
for all Button widgets by setting one draw method.

@section theme_instance_draw Widget Instance Draw Functions

It is currently not possible to change the draw() function for a specific
instance of a Widget.  To accomplish this task, you must inherit from the widget
type you wish to change and overload the draw() function.  Then, use the new
widget type.

*/
}}
