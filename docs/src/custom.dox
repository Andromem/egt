namespace egt { inline namespace v1 {
/**

 @page custom Creating New Widgets

This chapter discusses how to extend and customize widgets.

EGT is designed to support extension by way of custom widgets and functionality.
Essentially, to change the behavior or look and feel of an existing widget,
create a derived class of a similar and existing widget and reimplement the
functions that should be changed.  If you are creating a completely new type of
widget, you would inherit directly from Widget or one of the other base
widget types.

An example of this happening is fluent throughout the EGT library itself.  For
example, CheckBox implements a standard traditional checkBox that
shows an *X* when the checkBox is CheckBox::checked().  However, to change the look
and keep the same logical operation, ToggleBox derives from
CheckBox and changes the ToggleBox::draw() method.

The new widget class that only intends to change the look of a widget would look
something like this:

@code
    class ToggleBox : public CheckBox
    {
    public:
        explicit ToggleBox(const Rect& rect = Rect());

        virtual void draw(Painter& painter, const Rect& rect) override;

        virtual ~ToggleBox();
    };
@endcode

This new widget is basically a checkBox, but we want to change how it looks and
operates. The new ToggleBox::draw() method looks like this:

@code
void ToggleBox::draw(Painter& painter, const Rect& rect)
{
    draw_box(painter, Palette::ColorId::bg, Palette::ColorId::border);

    auto b = content_area();

    if (checked())
    {
        Rect rect = b;
        rect.set_width(rect.width() / 2);
        rect.set_x(rect.x() + rect.width());
        theme().draw_box(painter,
        {Theme::BoxFlag::fill, Theme::BoxFlag::border_rounded},
        rect,
        color(Palette::ColorId::border),
        color(Palette::ColorId::button_bg));
    }
    else
    {
        Rect rect = b;
        rect.set_width(rect.width() / 2);

        if (enable_disable())
        {
            theme().draw_box(painter,
            {Theme::BoxFlag::fill, Theme::BoxFlag::border_rounded},
            rect,
            color(Palette::ColorId::border, Palette::GroupId::disabled),
            color(Palette::ColorId::button_bg, Palette::GroupId::disabled));
        }
        else
        {
            theme().draw_box(painter,
            {Theme::BoxFlag::fill, Theme::BoxFlag::border_rounded},
            rect,
            color(Palette::ColorId::border),
            color(Palette::ColorId::button_bg));
        }
    }

    if (!on_text().empty())
    {
        Rect rect = b;
        rect.set_width(rect.width() / 2);
        rect.set_x(rect.x() + rect.width());

        if (checked())
            painter.set(color(Palette::ColorId::button_text).color());
        else
            painter.set(color(Palette::ColorId::button_text, Palette::GroupId::disabled).color());
        painter.set(font());
        auto size = painter.text_size(on_text());
        Rect target = detail::align_algorithm(size,
                                              rect,
                                              AlignFlag::center);
        painter.draw(target.point());
        painter.draw(on_text());
    }

    if (!off_text().empty())
    {
        Rect rect = b;
        rect.set_width(rect.width() / 2);

        if (checked())
            painter.set(color(Palette::ColorId::button_text, Palette::GroupId::disabled).color());
        else
            painter.set(color(Palette::ColorId::button_text, Palette::GroupId::disabled).color());
        painter.set(font());
        auto size = painter.text_size(off_text());
        Rect target = detail::align_algorithm(size,
                                              rect,
                                              AlignFlag::center);
        painter.draw(target.point());
        painter.draw(off_text());
    }
}
@endcode

*/
}}